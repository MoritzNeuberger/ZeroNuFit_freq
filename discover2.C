// profile likelihood fit of phase I data 
// 0.27% for 3 sigma
#include "TROOT.h"
#include "TCanvas.h"
#include "TString.h"
#include "TChain.h"
#include "TTree.h"
#include "TFile.h"
#include "TString.h"
#include "TGraph.h"
#include "TH1F.h"
#include "TH2F.h"
#include <string>
#include <fstream>
#include <iostream>
#include <vector>
#include <stdio.h>
#include <time.h>
#include "TMinuit.h"
#include <math.h>
#include <stdlib.h>
#include "TMath.h"
#include "TRandom3.h"
#include "pf.h"

int fcmp(const void *in1, const void *in2);


//______________________________________________________________________________
 int main()
{
// The z values
  Int_t i,k,j;
  Double_t best_invT12,tim,limit90,limit90low;
  TRandom3 *xr = new TRandom3();


  Int_t dim=240;   // energy interval size of fit
  Double_t  binwidth=get_binwidth(); 
  Double_t  maxinv = 0.2000;

  


    //--------------------------------------------
  //  first read in profile likelihood values for limit setting
  //  (like generated by cover2 but for 1/T=0 only)
  //  determine the value of the 99.7% quantile = 3sigma of the
  //  profile likelihood distribution
  TChain *mc = new TChain("toyMC");
  mc->Add("batch/cover2-discover.root");


  Double_t *ta;
  Int_t    ne=0;
  
  Double_t xinv, pval;
  mc->SetBranchAddress("invT12",&xinv);
  mc->SetBranchAddress("t",&pval);

  Double_t offset=binwidth/10.;


  Int_t tot = mc->GetEntries();
  

    ta = (Double_t*) malloc(sizeof(Double_t)*tot);
    if(!ta) printf("malloc failed\n");

  
  // reading in the test statistic from cover3.C output
  // profile t distribution
  for(int i=0; i<mc->GetEntries(); i++) {
    mc->GetEntry(i);
    *(ta + ne) = pval;
    ne++;
  }

  printf("sorting %d\n",ne);
  qsort((void *) ta, ne, sizeof(double), fcmp);

  int i003 = ne*997/1000;

  // print 3sigma profile likelihood value
  printf(" values 0.003 %f  \n",
	 *(ta+i003));

    printf("%e  %e %e %e %e\n",ta[ne/5],ta[2*ne/5],
	   ta[3*ne/5],ta[4*ne/5],ta[ne-1]);


  mc->Delete();

  //----------------------------------------------------
  // now read in the profile likelihood values generated by discover.C
  // for every 1/T sort the value and then check what fraction of toyMC
  // have a profile likelihood larger than the 3sigma value determined above
  
  Int_t nbins = dim;

  TChain *mc2 = new TChain("discover_toyMC");
  mc2->Add("batch/discover0.root");
  mc2->Add("batch/discover1.root");
  mc2->Add("batch/discover2.root");
  mc2->Add("batch/discover3.root");
  mc2->Add("batch/discover4.root");
  mc2->Add("batch/discover5.root");
  mc2->Add("batch/discover6.root");
  mc2->Add("batch/discover7.root");
  mc2->Add("batch/discover8.root");
  mc2->Add("batch/discover9.root");

  Double_t t0,xinv2;
  mc2->SetBranchAddress("invT12",&xinv2);
  mc2->SetBranchAddress("t",&t0);

  tot = mc2->GetEntries();

  printf("total number of entries %d  number of xinv bins %d\n",tot,nbins);

  Double_t t0arr[tot/nbins];

  printf("after \n\n");

  Int_t ncount;
  Double_t xb[nbins];
  Double_t discov[nbins];
  Double_t discov2[nbins];
  Double_t discov3[nbins];
  Double_t m[nbins];
  
  Double_t discover=0;

  for(k=0; k<nbins; k++) {
    ncount=0;
    discover=0;
    Double_t xinv = k*binwidth+binwidth/10.;
    xb[k]=xinv;
    
    for(int i=0; i<mc2->GetEntries(); i++) {
      mc2->GetEntry(i);
      Int_t ib = xinv2/binwidth;
      if(ib!=k) continue;  // skip of different 1/T value
      if(ncount>tot/nbins) {printf("array too small for element %d\n",i);break;}
      t0arr[ncount++] = t0;
    }

    // now count what fraction is larger than the 3sigma threshold
    for( j=0;j<ncount;j++) if(t0arr[j] >  *(ta+i003)) discover++;
    discov[k]=discover/ncount;
    printf("1/T=%f frac events with test stat for signal=0 > 3sigma  %f\n",
	   xinv,discov[k]);

    // p value: the way Matteo suggests: m = median of test statistic
    // distribution of the "discover" ntuple  for given 1/T,

    // loop over all test statistic "ta" values (from cover2) and check
    // what fraction is larger than m
    qsort((void *) t0arr, ncount, sizeof(double), fcmp);
    m[k]=t0arr[ncount/2];
    printf("%e  %e %e %e %e\n",t0arr[ncount/5],t0arr[2*ncount/5],
	   t0arr[3*ncount/5],t0arr[4*ncount/5],m[k]);

    // calculate the p value of the median m for  profile likelihood ta a litte smaller
    for(j=0;j<ne;j++) if( *(ta+j) > m[k]+1.E-6) break;
    discov2[k] = ((Double_t) j);
    // calculate the p value of the median m for  profile likelihood ta a litte larger
    for(j=ne-1;j>0;j--) if(m[k] >= *(ta+j)-0.5E-6) break;
    discov3[k]=j;
    discov2[k] = 1. - discov2[k]/ne;
    discov3[k] = 1. - discov3[k]/ne;
    printf("      median %f  fraction with t larger median %f %f %d\n",
	   m[k],discov2[k],discov3[k],j);

    // expect that discov2 and discov3 are identical. For small values of 1/T this is actually not the case
    // since the profile likelihood values are "discrete" for extreme conditions = small number of events
    // --> for plotting we will take the average of discov2 and discov3
  }

  mc2->Delete();

  // now save the output as histogram and graph for plotting
  
  TFile *fout = new TFile("discover_tmp.root","RECREATE");

  TH1F *me = new TH1F("median","median",nbins,0,nbins*binwidth);
  TH1F *d2 = new TH1F("discov_plus","discov_plus",nbins,0,nbins*binwidth);
  TH1F *d3 = new TH1F("discov_minus","discover_minus",nbins,0,nbins*binwidth);

  for(k=0;k<nbins;k++){
    me->SetBinContent(k+1,m[k]);
    d2->SetBinContent(k+1,discov2[k]);
    discov2[k] = 0.5*(discov2[k]+discov3[k]);  // take average, used for TGraph below 
    d3->SetBinContent(k+1,discov3[k]);
  }
  
  // fraction of toyMC with profile likelihood > 3sigma
  TGraph *tg = new TGraph(nbins,xb,discov);
  tg->SetTitle("discover_prob");
  tg->SetName("discover_prob");
  tg->Write();
  // p value of median discovery profile likelihood  
  TGraph *tg2 = new TGraph(nbins,xb,discov2);
  tg2->SetTitle("discover_pval");
  tg2->SetName("discover_pval");
  tg2->Write();

  fout->Write();
//
  fout->Close();



} // end main()
//-------------------------------------------------------------------------------
int fcmp(const void *in1, const void *in2) {
  double *d1 = (double *) in1;
  double *d2 = (double *) in2;
  if(*(d1) < * (d2) ) return -1;
  else if (*(d1) > * (d2) ) return 1;
  return 0;
}
